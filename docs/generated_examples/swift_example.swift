// This file was automatically generated by Beschi v0.3.0
// <https://github.com/sjml/beschi>
// Do not edit directly.

import Foundation

public /* namespace */ enum AppMessages {
    public enum DataReaderError: Error {
        case EOF
        case InvalidData
    }

    class DataReader {
        let data: Data
        var currentOffset: Int = 0
        init(fromData data: Data) {
            self.data = data
        }

        func IsFinished() -> Bool {
            return self.currentOffset >= self.data.count
        }

        func GetUInt8() throws -> UInt8 {
            if (self.data.count < self.currentOffset + 1) {
                throw DataReaderError.EOF
            }
            let ret = UInt8(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt8 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 1)
                return val
            })
            self.currentOffset += 1
            return ret
        }

        func GetBool() throws -> Bool {
            return try self.GetUInt8() > 0
        }

        func GetInt16() throws -> Int16 {
            if (self.data.count < self.currentOffset + 2) {
                throw DataReaderError.EOF
            }
            let ret = Int16(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: Int16 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 2)
                return val
            })
            self.currentOffset += 2
            return ret
        }

        func GetUInt16() throws -> UInt16 {
            if (self.data.count < self.currentOffset + 2) {
                throw DataReaderError.EOF
            }
            let ret = UInt16(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt16 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 2)
                return val
            })
            self.currentOffset += 2
            return ret
        }

        func GetInt32() throws -> Int32 {
            if (self.data.count < self.currentOffset + 4) {
                throw DataReaderError.EOF
            }
            let ret = Int32(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: Int32 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 4)
                return val
            })
            self.currentOffset += 4
            return ret
        }

        func GetUInt32() throws -> UInt32 {
            if (self.data.count < self.currentOffset + 4) {
                throw DataReaderError.EOF
            }
            let ret = UInt32(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt32 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 4)
                return val
            })
            self.currentOffset += 4
            return ret
        }

        func GetInt64() throws -> Int64 {
            if (self.data.count < self.currentOffset + 8) {
                throw DataReaderError.EOF
            }
            let ret = Int64(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: Int64 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 8)
                return val
            })
            self.currentOffset += 8
            return ret
        }

        func GetUInt64() throws -> UInt64 {
            if (self.data.count < self.currentOffset + 8) {
                throw DataReaderError.EOF
            }
            let ret = UInt64(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt64 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 8)
                return val
            })
            self.currentOffset += 8
            return ret
        }

        func GetFloat32() throws -> Float32 {
            if (self.data.count < self.currentOffset + 4) {
                throw DataReaderError.EOF
            }
            let ret = Float32(bitPattern: UInt32(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt32 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 4)
                return val
            }))
            self.currentOffset += 4
            return ret
        }

        func GetFloat64() throws -> Float64 {
            if (self.data.count < self.currentOffset + 8) {
                throw DataReaderError.EOF
            }
            let ret = Float64(bitPattern: UInt64(littleEndian: data.withUnsafeBytes { dataBytes in
                var val: UInt64 = 0
                memcpy(&val, dataBytes.baseAddress! + self.currentOffset, 8)
                return val
            }))
            self.currentOffset += 8
            return ret
        }

        func GetString() throws -> String {
            let stringLength = try Int(self.GetUInt8())
            if (self.data.count < self.currentOffset + stringLength) {
                throw DataReaderError.EOF
            }
            let stringData = self.data[self.currentOffset..<(self.currentOffset+stringLength)]
            guard
                let ret = String(data: stringData, encoding: String.Encoding.utf8)
            else {
                throw DataReaderError.InvalidData
            }
            self.currentOffset += stringLength
            return ret
        }
    }

    class DataWriter {
        var data: NSMutableData

        init() {
            self.data = NSMutableData()
        }

        init(withData: NSMutableData) {
            self.data = withData
        }

        var asData: Data {
            return self.data as Data
        }

        func Write(uint8: UInt8) {
            var val = uint8;
            self.data.append(&val, length: MemoryLayout<UInt8>.size);
        }

        func Write(bool: Bool) {
            self.Write(uint8: bool ? 1 : 0)
        }

        func Write(int16: Int16) {
            var val = int16;
            self.data.append(&val, length: MemoryLayout<Int16>.size);
        }

        func Write(uint16: UInt16) {
            var val = uint16;
            self.data.append(&val, length: MemoryLayout<UInt16>.size);
        }

        func Write(int32: Int32) {
            var val = int32;
            self.data.append(&val, length: MemoryLayout<Int32>.size);
        }

        func Write(uint32: UInt32) {
            var val = uint32;
            self.data.append(&val, length: MemoryLayout<UInt32>.size);
        }

        func Write(int64: Int64) {
            var val = int64;
            self.data.append(&val, length: MemoryLayout<Int64>.size);
        }

        func Write(uint64: UInt64) {
            var val = uint64;
            self.data.append(&val, length: MemoryLayout<UInt64>.size);
        }

        func Write(float32: Float32) {
            var val = float32;
            var valOut = UInt32(littleEndian: withUnsafeBytes(of: &val) {
                $0.load(fromByteOffset: 0, as: UInt32.self)
            })
            self.data.append(&valOut, length: MemoryLayout<UInt32>.size);
        }

        func Write(float64: Float64) {
            var val = float64;
            var valOut = UInt64(littleEndian: withUnsafeBytes(of: &val) {
                $0.load(fromByteOffset: 0, as: UInt64.self)
            })
            self.data.append(&valOut, length: MemoryLayout<UInt64>.size);
        }

        func Write(string: String) {
            let buffer = string.data(using: .utf8)!
            self.Write(uint8: UInt8(buffer.count))
            self.data.append(buffer)
        }
    }


    public class Message {
        public func GetMessageType() -> MessageType {
            fatalError("GetMessageType must be implemented in subclass")
        }
        public func WriteBytes(data: NSMutableData, tag: Bool) -> Void {
            fatalError("WriteBytes must be implemented in subclass")
        }
        public func GetSizeInBytes() -> UInt32 {
            fatalError("GetSizeInBytes must be implemented in subclass")
        }
        public class func FromBytes(_ fromData: Data) throws -> Self {
            fatalError("FromBytes:fromData must be implemented in subclass")
        }
        class func FromBytes(dataReader: DataReader) throws -> Self {
            fatalError("FromBytes:dataReader must be implemented in subclass")
        }

        public static func UnpackMessages(_ data: Data) throws -> [Message] {
            let dataReader = DataReader(fromData: data)
            let headerBytes = dataReader.data[dataReader.currentOffset..<dataReader.currentOffset+4];
            guard
                let headerLabel = String(data: headerBytes, encoding: String.Encoding.utf8)
            else {
                throw DataReaderError.InvalidData
            }
            dataReader.currentOffset += 4
            if headerLabel != "BSCI" {
                throw DataReaderError.InvalidData
            }
            let msgCount = try dataReader.GetUInt32();
            if msgCount == 0 {
                return [Message]()
            }
            let listData = data.subdata(in: dataReader.currentOffset..<dataReader.data.count)
            let msgList: [Message] = try ProcessRawBytes(listData, max: Int(msgCount))
            if msgList.count == 0 {
                throw DataReaderError.InvalidData
            }
            if msgList.count != msgCount {
                throw DataReaderError.InvalidData
            }
            return msgList.compactMap { $0 }
        }
    }

    public enum MessageType: UInt8 {
        case Vector3MessageType = 1
        case NewCharacterMessageType = 2
        case CharacterJoinedTeamType = 3
    }

    public static func ProcessRawBytes(_ data: Data, max: Int) throws -> [Message] {
        var msgList: [Message] = []
        if max == 0 {
            return msgList
        }
        let dr = DataReader(fromData: data)
        while !dr.IsFinished() && (max < 0 || msgList.count < max) {
            let msgTypeByte = try dr.GetUInt8()
            if msgTypeByte == 0 {
                return msgList
            }
            guard let msgType = AppMessages.MessageType(rawValue: msgTypeByte)
            else {
                throw DataReaderError.InvalidData
            }
            switch msgType {
                case AppMessages.MessageType.Vector3MessageType:
                    msgList.append(try Vector3Message.FromBytes(dataReader: dr))
                case AppMessages.MessageType.NewCharacterMessageType:
                    msgList.append(try NewCharacterMessage.FromBytes(dataReader: dr))
                case AppMessages.MessageType.CharacterJoinedTeamType:
                    msgList.append(try CharacterJoinedTeam.FromBytes(dataReader: dr))
            }
        }
        return msgList
    }

    public enum CharacterClass: UInt8 {
        case Fighter = 0
        case Wizard = 1
        case Rogue = 2
        case Cleric = 3
    }

    public enum TeamRole: Int16 {
        case Minion = 256
        case Ally = 512
        case Leader = 1024
        case Traitor = -1
    }

    public struct Color {
        public var red: Float32 = 0.0
        public var green: Float32 = 0.0
        public var blue: Float32 = 0.0
        public var alpha: Float32 = 0.0

        public init() {}

        static func FromBytes(dataReader: DataReader) throws -> Self {
            var nColor = Self.init()
            nColor.red = try dataReader.GetFloat32()
            nColor.green = try dataReader.GetFloat32()
            nColor.blue = try dataReader.GetFloat32()
            nColor.alpha = try dataReader.GetFloat32()
            return nColor
        }

        func WriteBytes(_ dataWriter: DataWriter) -> Void {
            dataWriter.Write(float32: self.red)
            dataWriter.Write(float32: self.green)
            dataWriter.Write(float32: self.blue)
            dataWriter.Write(float32: self.alpha)
        }
    }

    public struct Spectrum {
        public var defaultColor: Color = Color()
        public var colors: [Color] = []

        public init() {}

        static func FromBytes(dataReader: DataReader) throws -> Self {
            var nSpectrum = Self.init()
            nSpectrum.defaultColor = try Color.FromBytes(dataReader: dataReader)
            let colors_Length = try dataReader.GetUInt16()
            nSpectrum.colors = []
            for _ in 0..<colors_Length {
                let _colors_el = try Color.FromBytes(dataReader: dataReader)
                nSpectrum.colors.append(_colors_el)
            }
            return nSpectrum
        }

        func WriteBytes(_ dataWriter: DataWriter) -> Void {
            self.defaultColor.WriteBytes(dataWriter)
            dataWriter.Write(uint16: UInt16(self.colors.count))
            for el in self.colors {
                el.WriteBytes(dataWriter)
            }
        }
    }

    public class Vector3Message: Message {
        public var x: Float32 = 0.0
        public var y: Float32 = 0.0
        public var z: Float32 = 0.0

        public required override init() {}

        public override func GetMessageType() -> MessageType {
            return MessageType.Vector3MessageType
        }

        public override func GetSizeInBytes() -> UInt32 {
            return 12;
        }

        public override class func FromBytes(_ fromData: Data) throws -> Self {
            let dr = DataReader(fromData: fromData)
            return try FromBytes(dataReader: dr)
        }

        override class func FromBytes(dataReader: DataReader) throws -> Self {
            let nVector3Message = Self.init()
            nVector3Message.x = try dataReader.GetFloat32()
            nVector3Message.y = try dataReader.GetFloat32()
            nVector3Message.z = try dataReader.GetFloat32()
            return nVector3Message
        }

        public override func WriteBytes(data: NSMutableData, tag: Bool) -> Void {
            let dataWriter = DataWriter(withData: data)
            if (tag) {
                dataWriter.Write(uint8: MessageType.Vector3MessageType.rawValue)
            }
            dataWriter.Write(float32: self.x)
            dataWriter.Write(float32: self.y)
            dataWriter.Write(float32: self.z)
        }
    }

    public class NewCharacterMessage: Message {
        public var id: UInt64 = 0
        public var characterName: String = ""
        public var job: CharacterClass = CharacterClass.Fighter
        public var strength: UInt16 = 0
        public var intelligence: UInt16 = 0
        public var dexterity: UInt16 = 0
        public var wisdom: UInt16 = 0
        public var goldInWallet: UInt32 = 0
        public var nicknames: [String] = []

        public required override init() {}

        public override func GetMessageType() -> MessageType {
            return MessageType.NewCharacterMessageType
        }

        public override func GetSizeInBytes() -> UInt32 {
            var size = 0
            size += self.characterName.data(using: String.Encoding.utf8)!.count
            for s in self.nicknames {
                size += 1 + s.data(using: String.Encoding.utf8)!.count
            }
            size += 24;
            return UInt32(size)
        }

        public override class func FromBytes(_ fromData: Data) throws -> Self {
            let dr = DataReader(fromData: fromData)
            return try FromBytes(dataReader: dr)
        }

        override class func FromBytes(dataReader: DataReader) throws -> Self {
            let nNewCharacterMessage = Self.init()
            nNewCharacterMessage.id = try dataReader.GetUInt64()
            nNewCharacterMessage.characterName = try dataReader.GetString()
            let _jobRead = try dataReader.GetUInt8()
            guard let _job = CharacterClass(rawValue: _jobRead) else {
                throw DataReaderError.InvalidData
            }
            nNewCharacterMessage.job = _job
            nNewCharacterMessage.strength = try dataReader.GetUInt16()
            nNewCharacterMessage.intelligence = try dataReader.GetUInt16()
            nNewCharacterMessage.dexterity = try dataReader.GetUInt16()
            nNewCharacterMessage.wisdom = try dataReader.GetUInt16()
            nNewCharacterMessage.goldInWallet = try dataReader.GetUInt32()
            let nicknames_Length = try dataReader.GetUInt16()
            nNewCharacterMessage.nicknames = []
            for _ in 0..<nicknames_Length {
                let _nicknames_el = try dataReader.GetString()
                nNewCharacterMessage.nicknames.append(_nicknames_el)
            }
            return nNewCharacterMessage
        }

        public override func WriteBytes(data: NSMutableData, tag: Bool) -> Void {
            let dataWriter = DataWriter(withData: data)
            if (tag) {
                dataWriter.Write(uint8: MessageType.NewCharacterMessageType.rawValue)
            }
            dataWriter.Write(uint64: self.id)
            dataWriter.Write(string: self.characterName)
            dataWriter.Write(uint8: self.job.rawValue)
            dataWriter.Write(uint16: self.strength)
            dataWriter.Write(uint16: self.intelligence)
            dataWriter.Write(uint16: self.dexterity)
            dataWriter.Write(uint16: self.wisdom)
            dataWriter.Write(uint32: self.goldInWallet)
            dataWriter.Write(uint16: UInt16(self.nicknames.count))
            for el in self.nicknames {
                dataWriter.Write(string: el)
            }
        }
    }

    public class CharacterJoinedTeam: Message {
        public var characterID: UInt64 = 0
        public var teamName: String = ""
        public var teamColors: [Color] = []
        public var role: TeamRole = TeamRole.Minion

        public required override init() {}

        public override func GetMessageType() -> MessageType {
            return MessageType.CharacterJoinedTeamType
        }

        public override func GetSizeInBytes() -> UInt32 {
            var size = 0
            size += self.teamName.data(using: String.Encoding.utf8)!.count
            size += self.teamColors.count * 16
            size += 13;
            return UInt32(size)
        }

        public override class func FromBytes(_ fromData: Data) throws -> Self {
            let dr = DataReader(fromData: fromData)
            return try FromBytes(dataReader: dr)
        }

        override class func FromBytes(dataReader: DataReader) throws -> Self {
            let nCharacterJoinedTeam = Self.init()
            nCharacterJoinedTeam.characterID = try dataReader.GetUInt64()
            nCharacterJoinedTeam.teamName = try dataReader.GetString()
            let teamColors_Length = try dataReader.GetUInt16()
            nCharacterJoinedTeam.teamColors = []
            for _ in 0..<teamColors_Length {
                let _teamColors_el = try Color.FromBytes(dataReader: dataReader)
                nCharacterJoinedTeam.teamColors.append(_teamColors_el)
            }
            let _roleRead = try dataReader.GetInt16()
            guard let _role = TeamRole(rawValue: _roleRead) else {
                throw DataReaderError.InvalidData
            }
            nCharacterJoinedTeam.role = _role
            return nCharacterJoinedTeam
        }

        public override func WriteBytes(data: NSMutableData, tag: Bool) -> Void {
            let dataWriter = DataWriter(withData: data)
            if (tag) {
                dataWriter.Write(uint8: MessageType.CharacterJoinedTeamType.rawValue)
            }
            dataWriter.Write(uint64: self.characterID)
            dataWriter.Write(string: self.teamName)
            dataWriter.Write(uint16: UInt16(self.teamColors.count))
            for el in self.teamColors {
                el.WriteBytes(dataWriter)
            }
            dataWriter.Write(int16: self.role.rawValue)
        }
    }

}

extension Array where Element == AppMessages.Message {
    public func GetPackedSize() -> Int {
        var size: Int = 0
        for msg in self {
            size += Int(msg.GetSizeInBytes())
        }
        size += self.count
        size += 9
        return size
    }

    public func PackMessages(_ data: NSMutableData) -> Void {
        let dataWriter = AppMessages.DataWriter(withData: data)
        let headerBytes = "BSCI".data(using: String.Encoding.utf8)!
        dataWriter.data.append(headerBytes)
        var msgCount = UInt32(littleEndian: UInt32(self.count))
        dataWriter.data.append(Swift.withUnsafeBytes(of: &msgCount, {Data($0)}))
        for msg in self {
            msg.WriteBytes(data: dataWriter.data, tag: true)
        }
        dataWriter.Write(uint8: 0)
    }
}
