// This file was automatically generated by Beschi v0.3.0
// <https://github.com/sjml/beschi>
// Do not edit directly.


export class DataAccess {
  data: DataView;
  currentOffset: u32;

  constructor(buffer: DataView) {
    this.currentOffset = 0;
    this.data = buffer;
  }

  isFinished(): bool {
    return this.currentOffset >= this.data.byteLength;
  }

  getByte(): u8 {
    const ret = this.data.getUint8(this.currentOffset);
    this.currentOffset += 1;
    return ret;
  }

  getBool(): bool {
    return this.getByte() > 0;
  }

  getInt16(): i16 {
    const ret = this.data.getInt16(this.currentOffset, true);
    this.currentOffset += 2;
    return ret;
  }

  getUint16(): u16 {
    const ret = this.data.getUint16(this.currentOffset, true);
    this.currentOffset += 2;
    return ret;
  }

  getInt32(): i32 {
    const ret = this.data.getInt32(this.currentOffset, true);
    this.currentOffset += 4;
    return ret;
  }

  getUint32(): u32 {
    const ret = this.data.getUint32(this.currentOffset, true);
    this.currentOffset += 4;
    return ret;
  }

  getInt64(): i64 {
    const ret = this.data.getInt64(this.currentOffset, true);
    this.currentOffset += 8;
    return ret;
  }

  getUint64(): u64 {
    const ret = this.data.getUint64(this.currentOffset, true);
    this.currentOffset += 8;
    return ret;
  }

  getFloat32(): f32 {
    const ret = this.data.getFloat32(this.currentOffset, true);
    this.currentOffset += 4;
    return ret;
  }

  getFloat64(): f64 {
    const ret = this.data.getFloat64(this.currentOffset, true);
    this.currentOffset += 8;
    return ret;
  }

  getString(): string {
    const len = this.getByte();
    const strBuffer = new Uint8Array(len);
    for (let i = 0; i < strBuffer.byteLength; i++) {
        strBuffer[i] = this.getByte();
    }
    return String.UTF8.decode(strBuffer.buffer, false);
  }


  setByte(val: u8): void {
    this.data.setUint8(this.currentOffset, val);
    this.currentOffset += 1;
  }

  setBool(val: bool): void {
    this.setByte(val ? 1 : 0);
  }

  setInt16(val: i16): void {
    this.data.setInt16(this.currentOffset, val, true);
    this.currentOffset += 2;
  }

  setUint16(val: u16): void {
    this.data.setUint16(this.currentOffset, val, true);
    this.currentOffset += 2;
  }

  setInt32(val: i32): void {
    this.data.setInt32(this.currentOffset, val, true);
    this.currentOffset += 4;
  }

  setUint32(val: u32): void {
    this.data.setUint32(this.currentOffset, val, true);
    this.currentOffset += 4;
  }

  setInt64(val: i64): void {
    this.data.setInt64(this.currentOffset, val, true);
    this.currentOffset += 8;
  }

  setUint64(val: u64): void {
    this.data.setUint64(this.currentOffset, val, true);
    this.currentOffset += 8;
  }

  setFloat32(val: f32): void {
    this.data.setFloat32(this.currentOffset, val, true);
    this.currentOffset += 4;
  }

  setFloat64(val: f64): void {
    this.data.setFloat64(this.currentOffset, val, true);
    this.currentOffset += 8;
  }

  setString(val: string): void {
    const strBuffer = String.UTF8.encode(val, false);
    const bufferArray = Uint8Array.wrap(strBuffer);
    this.setByte(strBuffer.byteLength as u8);
    for (let i = 0; i < bufferArray.byteLength; i++) {
      this.setByte(bufferArray[i] as u8);
    }
  }
}

export abstract class Message {
  abstract getMessageType(): MessageType;
  abstract writeBytes(dv: DataView, tag: bool): void;
  abstract getSizeInBytes(): usize;

  static fromBytes(data: DataView): Message | null {
    throw new Error("Cannot read abstract Message from bytes.");
  };
}

export function GetPackedSize(msgList: Message[]): usize {
  let size = 0;
  for (const msg of msgList) {
    size += msg.getSizeInBytes();
  }
  size += msgList.length;
  size += 9;
  return size;
}

export function PackMessages(msgList: Message[], data: DataView): void {
  const da = new DataAccess(data);
  const headerBytes = String.UTF8.encode("BSCI", false);
  const arr = new Uint8Array(da.data.buffer);
  arr.set(headerBytes, da.currentOffset);
  da.currentOffset += headerBytes.byteLength;
  da.setUint32(msgList.length);
  for (const msg of msgList) {
    msg.writeBytes(da, true);
  }
  da.setByte(0);
}

export function UnpackMessages(data: DataView): Message[] {
  const da = new DataAccess(data);
  const headerBuffer = new Uint8Array(da.data.buffer, da.currentOffset, 4);
  da.currentOffset += 4;
  const headerLabel = String.UTF8.decode(headerBuffer, false);
  if (headerLabel !== "BSCI") {
    throw new Error("Packed message buffer has invalid header.");
  }
  const msgCount = da.getUint32();
  if (msgCount == 0) {
    return [];
  }
  const msgList = ProcessRawBytes(da, msgCount);
  if (msgList.length == 0) {
    throw new Error("No messages in buffer.");
  }
  if (msgList.length != msgCount) {
    throw new Error("Unexpected number of messages in buffer.");
  }
  return msgList;
}

export enum MessageType {
  Vector3MessageType = 1,
  NewCharacterMessageType = 2,
  CharacterJoinedTeamType = 3,
  _Unknown,
}

export function ProcessRawBytes(data: DataView, max: number): Message[] {
  if (max === undefined) {
    max = -1;
  }
  const da = new DataAccess(data);
  const msgList: Message[] = [];
  if (max == 0) {
    return msgList;
  }
  while (!da.isFinished() && (max < 0 || msgList.length < max)) {
    const msgType: number = da.getByte();
    switch (msgType) {
      case 0:
        return msgList;
      case MessageType.Vector3MessageType:
        msgList.push(Vector3Message.fromBytes(da));
        break;
      case MessageType.NewCharacterMessageType:
        msgList.push(NewCharacterMessage.fromBytes(da));
        break;
      case MessageType.CharacterJoinedTeamType:
        msgList.push(CharacterJoinedTeam.fromBytes(da));
        break;
      default:
        throw new Error(`Unknown message type: ${msgType}`);
    }
  }
  return msgList;
}

export enum CharacterClass {
  Fighter = 0,
  Wizard = 1,
  Rogue = 2,
  Cleric = 3,
  _Unknown,
}

export enum TeamRole {
  Minion = 256,
  Ally = 512,
  Leader = 1024,
  Traitor = -1,
  _Unknown,
}

export class Color {
  red: f32 = 0;
  green: f32 = 0;
  blue: f32 = 0;
  alpha: f32 = 0;

  static fromBytes(da: DataAccess): Color {
    const nColor = new Color();
    nColor.red = da.getFloat32();
    nColor.green = da.getFloat32();
    nColor.blue = da.getFloat32();
    nColor.alpha = da.getFloat32();
    return nColor;
  }

  writeBytes(da: DataAccess): void {
    da.setFloat32(this.red);
    da.setFloat32(this.green);
    da.setFloat32(this.blue);
    da.setFloat32(this.alpha);
  }

}

export class Spectrum {
  defaultColor: Color = new Color();
  colors: Color[] = [];

  static fromBytes(da: DataAccess): Spectrum {
    const nSpectrum = new Spectrum();
    nSpectrum.defaultColor = Color.fromBytes(da);
    const colors_Length = da.getUint16();
    nSpectrum.colors = new Array<Color>(colors_Length);
    for (let i2: u16 = 0; i2 < colors_Length; i2++) {
      nSpectrum.colors[i2] = Color.fromBytes(da);
    }
    return nSpectrum;
  }

  writeBytes(da: DataAccess): void {
    this.defaultColor.writeBytes(da);
    da.setUint16(this.colors.length as u16);
    for (let i = 0; i < this.colors.length; i++) {
      let el = this.colors[i];
      el.writeBytes(da);
    }
  }

}

export class Vector3Message extends Message {
  x: f32 = 0;
  y: f32 = 0;
  z: f32 = 0;

  getMessageType() : MessageType { return MessageType.Vector3MessageType; }

  getSizeInBytes(): usize {
    return 12;
  }

  static override fromBytes(data: DataView): Vector3Message {
    const da = new DataAccess(data);
    const nVector3Message = new Vector3Message();
    nVector3Message.x = da.getFloat32();
    nVector3Message.y = da.getFloat32();
    nVector3Message.z = da.getFloat32();
    return nVector3Message;
  }

  writeBytes(data: DataView, tag: boolean): void {
    const da = new DataAccess(data);
    if (tag) {
      da.setByte(MessageType.Vector3MessageType as u8);
    }
    da.setFloat32(this.x);
    da.setFloat32(this.y);
    da.setFloat32(this.z);
  }

}

export class NewCharacterMessage extends Message {
  id: u64 = 0;
  characterName: string = "";
  job: CharacterClass = CharacterClass.Fighter;
  strength: u16 = 0;
  intelligence: u16 = 0;
  dexterity: u16 = 0;
  wisdom: u16 = 0;
  goldInWallet: u32 = 0;
  nicknames: string[] = [];

  getMessageType() : MessageType { return MessageType.NewCharacterMessageType; }

  getSizeInBytes(): usize {
    let size: usize = 0;
    size += String.UTF8.encode(this.characterName, false).byteLength;
    for (let nicknames_i=0; nicknames_i < this.nicknames.length; nicknames_i++) {
      size += 1 + String.UTF8.encode(this.nicknames[nicknames_i], false).byteLength;
    }
    size += 24;
    return size;
  }

  static override fromBytes(data: DataView): NewCharacterMessage {
    const da = new DataAccess(data);
    const nNewCharacterMessage = new NewCharacterMessage();
    nNewCharacterMessage.id = da.getUint64();
    nNewCharacterMessage.characterName = da.getString();
    const _job = da.getByte();
    if (_job < 0 || _job >= (CharacterClass._Unknown as u8)) {
      throw new Error(`Enum (${_job}) out of range for CharacterClass`);
    }
    nNewCharacterMessage.job = _job;
    nNewCharacterMessage.strength = da.getUint16();
    nNewCharacterMessage.intelligence = da.getUint16();
    nNewCharacterMessage.dexterity = da.getUint16();
    nNewCharacterMessage.wisdom = da.getUint16();
    nNewCharacterMessage.goldInWallet = da.getUint32();
    const nicknames_Length = da.getUint16();
    nNewCharacterMessage.nicknames = new Array<string>(nicknames_Length);
    for (let i2: u16 = 0; i2 < nicknames_Length; i2++) {
      nNewCharacterMessage.nicknames[i2] = da.getString();
    }
    return nNewCharacterMessage;
  }

  writeBytes(data: DataView, tag: boolean): void {
    const da = new DataAccess(data);
    if (tag) {
      da.setByte(MessageType.NewCharacterMessageType as u8);
    }
    da.setUint64(this.id);
    da.setString(this.characterName);
    da.setByte(this.job as u8);
    da.setUint16(this.strength);
    da.setUint16(this.intelligence);
    da.setUint16(this.dexterity);
    da.setUint16(this.wisdom);
    da.setUint32(this.goldInWallet);
    da.setUint16(this.nicknames.length as u16);
    for (let i = 0; i < this.nicknames.length; i++) {
      let el = this.nicknames[i];
      da.setString(el);
    }
  }

}

export class CharacterJoinedTeam extends Message {
  characterID: u64 = 0;
  teamName: string = "";
  teamColors: Color[] = [];
  role: TeamRole = TeamRole.Minion;

  getMessageType() : MessageType { return MessageType.CharacterJoinedTeamType; }

  getSizeInBytes(): usize {
    let size: usize = 0;
    size += String.UTF8.encode(this.teamName, false).byteLength;
    size += this.teamColors.length * 16;
    size += 13;
    return size;
  }

  static override fromBytes(data: DataView): CharacterJoinedTeam {
    const da = new DataAccess(data);
    const nCharacterJoinedTeam = new CharacterJoinedTeam();
    nCharacterJoinedTeam.characterID = da.getUint64();
    nCharacterJoinedTeam.teamName = da.getString();
    const teamColors_Length = da.getUint16();
    nCharacterJoinedTeam.teamColors = new Array<Color>(teamColors_Length);
    for (let i2: u16 = 0; i2 < teamColors_Length; i2++) {
      nCharacterJoinedTeam.teamColors[i2] = Color.fromBytes(da);
    }
    const _role = da.getInt16();
    if (_role < -1 || _role >= (TeamRole._Unknown as i16)) {
      throw new Error(`Enum (${_role}) out of range for TeamRole`);
    }
    nCharacterJoinedTeam.role = _role;
    return nCharacterJoinedTeam;
  }

  writeBytes(data: DataView, tag: boolean): void {
    const da = new DataAccess(data);
    if (tag) {
      da.setByte(MessageType.CharacterJoinedTeamType as u8);
    }
    da.setUint64(this.characterID);
    da.setString(this.teamName);
    da.setUint16(this.teamColors.length as u16);
    for (let i = 0; i < this.teamColors.length; i++) {
      let el = this.teamColors[i];
      el.writeBytes(da);
    }
    da.setInt16(this.role as i16);
  }

}

