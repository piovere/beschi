// This file was automatically generated by Beschi v0.3.0
// <https://github.com/sjml/beschi>
// Do not edit directly.

#![allow(dead_code)] // some generated functions chains may not be fully exploited

use std::fmt;
use std::error::Error;

#[derive(Debug)]
pub enum AppMessagesError {
    EndOfFile,
    InvalidData,
    EndOfMessageList,
}

impl Error for AppMessagesError {}

impl fmt::Display for AppMessagesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppMessagesError::EndOfFile => write!(f, "end of file reached prematurely"),
            AppMessagesError::InvalidData => write!(f, "invalid data encountered"),
            AppMessagesError::EndOfMessageList => write!(f, "end of message list encountered"),
        }
    }
}

pub struct BufferReader<'a> {
    buffer: &'a [u8],
    pub current_position: usize,
}

impl<'a> BufferReader<'a> {
    pub fn new(buffer: &'a [u8]) -> Self {
        BufferReader { buffer, current_position: 0 }
    }

    pub fn from_vec(buffer: Vec<u8>) -> BufferReader<'static> {
        let buffer = Box::new(buffer);
        BufferReader {
            buffer: Box::leak(buffer),
            current_position: 0,
        }
    }

    pub fn is_finished(&self) -> bool {
        self.current_position >= self.buffer.len()
    }

    pub fn has_remaining(&self, size: usize) -> bool {
        self.current_position + size <= self.buffer.len()
    }

    pub fn take_byte(&mut self) -> Result<u8, AppMessagesError> {
        if !self.has_remaining(1) {
            return Err(AppMessagesError::EndOfFile);
        }
        self.current_position += 1;
        Ok(self.buffer[self.current_position-1])
    }

    pub fn take(&mut self, amount: usize) -> Result<&[u8], AppMessagesError> {
        if !self.has_remaining(amount) {
            return Err(AppMessagesError::EndOfFile);
        }

        let ret: &[u8] = &self.buffer[self.current_position..self.current_position+amount];
        self.current_position += amount;
        Ok(ret)
    }

    pub fn read_string(&mut self) -> Result<String, AppMessagesError> {
        let len = self.read_u8()?;
        let string_bytes = self.take(len as usize)?;
        match String::from_utf8(string_bytes.to_vec()) {
            Err(_) => Err(AppMessagesError::InvalidData),
            Ok(v) => Ok(v)
        }
    }

    pub fn read_u8(&mut self) -> Result<u8, AppMessagesError> {
        let byte = self.take_byte()?;
        Ok(byte)
    }

    pub fn read_i16(&mut self) -> Result<i16, AppMessagesError> {
        let bytes = self.take(2)?;
        Ok(i16::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u16(&mut self) -> Result<u16, AppMessagesError> {
        let bytes = self.take(2)?;
        Ok(u16::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_i32(&mut self) -> Result<i32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(i32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u32(&mut self) -> Result<u32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(u32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_i64(&mut self) -> Result<i64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(i64::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u64(&mut self) -> Result<u64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(u64::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_f32(&mut self) -> Result<f32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(f32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_f64(&mut self) -> Result<f64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(f64::from_le_bytes(bytes.try_into().unwrap()))
    }
}

pub trait MessageCodec {
    fn get_message_type(&self) -> MessageType;
    fn get_size_in_bytes(&self) -> usize;
    fn from_bytes(reader: &mut BufferReader) -> Result<Self, AppMessagesError>
        where Self: Sized;
    fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool);
}


pub fn get_packed_size(msg_list: &[Message]) -> usize {
    let mut size: usize = 0;

    for msg in msg_list {
        size += msg.get_size_in_bytes();
    }
    size += msg_list.len();
    size += 9;

    size
}

pub fn pack_messages(msg_list: &[Message], writer: &mut Vec<u8>) {
    let header_bytes = b"BSCI";
    writer.extend_from_slice(header_bytes);
    let msg_count = msg_list.len() as u32;
    writer.extend_from_slice(&msg_count.to_le_bytes());

    for msg in msg_list {
        msg.write_bytes(writer, true);
    }
    writer.push(0);
}

pub fn unpack_messages(reader: &mut BufferReader) -> Result<Vec<Message>, AppMessagesError> {
    let header_label = reader.take(4)?;
    if header_label != b"BSCI" {
        return Err(AppMessagesError::InvalidData);
    }

    let msg_count = reader.read_u32()? as usize;
    if msg_count == 0 {
        return Ok(Vec::new());
    }

    let msg_list = process_raw_bytes(reader, msg_count as i32)?;
    let read_count = msg_list.len();
    if read_count == 0 {
        return Err(AppMessagesError::InvalidData);
    }
    if msg_list.len() != msg_count {
        return Err(AppMessagesError::InvalidData);
    }

    Ok(msg_list)
}

pub enum MessageType {
    Vector3Message,
    NewCharacterMessage,
    CharacterJoinedTeam,
}

pub enum Message {
    Vector3Message(Vector3Message),
    NewCharacterMessage(NewCharacterMessage),
    CharacterJoinedTeam(CharacterJoinedTeam),
}

impl MessageCodec for Message {
    fn get_message_type(&self) -> MessageType {
        match self {
            Message::Vector3Message(_) => MessageType::Vector3Message,
            Message::NewCharacterMessage(_) => MessageType::NewCharacterMessage,
            Message::CharacterJoinedTeam(_) => MessageType::CharacterJoinedTeam,
        }
    }

    fn get_size_in_bytes(&self) -> usize {
        match self {
            Message::Vector3Message(msg) => msg.get_size_in_bytes(),
            Message::NewCharacterMessage(msg) => msg.get_size_in_bytes(),
            Message::CharacterJoinedTeam(msg) => msg.get_size_in_bytes(),
        }
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<Message, AppMessagesError> {
        let tag = reader.take_byte()?;
        let msg = match tag {
            0 => return Err(AppMessagesError::EndOfMessageList),
            1 => Message::Vector3Message(Vector3Message::from_bytes(reader)?),
            2 => Message::NewCharacterMessage(NewCharacterMessage::from_bytes(reader)?),
            3 => Message::CharacterJoinedTeam(CharacterJoinedTeam::from_bytes(reader)?),
            _ => return Err(AppMessagesError::InvalidData),
        };
        Ok(msg)
    }

    fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        match self {
            Message::Vector3Message(msg) => msg.write_bytes(writer, tag),
            Message::NewCharacterMessage(msg) => msg.write_bytes(writer, tag),
            Message::CharacterJoinedTeam(msg) => msg.write_bytes(writer, tag),
        }
    }
}

pub fn process_raw_bytes(reader: &mut BufferReader, max: i32) -> Result<Vec<Message>, AppMessagesError> {
    let mut msg_list: Vec<Message> = Vec::new();
    if max == 0 {
        return Ok(msg_list);
    }
    while !reader.is_finished() && (max < 0 || msg_list.len() < max as usize) {
        match Message::from_bytes(reader) {
            Err(e) => match e {
                AppMessagesError::EndOfMessageList => return Ok(msg_list),
                _ => return Err(e),
            }
            Ok(msg) => msg_list.push(msg),
        }
    }
    Ok(msg_list)
}

#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CharacterClass {
    Fighter = 0,
    Wizard = 1,
    Rogue = 2,
    Cleric = 3,
}

impl Default for CharacterClass {
    fn default() -> Self { CharacterClass::Fighter }
}

impl TryFrom<u8> for CharacterClass {
    type Error = AppMessagesError;

    fn try_from(value: u8) -> Result<Self, AppMessagesError> {
        match value {
            0 => Ok(CharacterClass::Fighter),
            1 => Ok(CharacterClass::Wizard),
            2 => Ok(CharacterClass::Rogue),
            3 => Ok(CharacterClass::Cleric),
            _ => Err(AppMessagesError::InvalidData)
        }
    }
}

#[repr(i16)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum TeamRole {
    Minion = 256,
    Ally = 512,
    Leader = 1024,
    Traitor = -1,
}

impl Default for TeamRole {
    fn default() -> Self { TeamRole::Minion }
}

impl TryFrom<i16> for TeamRole {
    type Error = AppMessagesError;

    fn try_from(value: i16) -> Result<Self, AppMessagesError> {
        match value {
            256 => Ok(TeamRole::Minion),
            512 => Ok(TeamRole::Ally),
            1024 => Ok(TeamRole::Leader),
            -1 => Ok(TeamRole::Traitor),
            _ => Err(AppMessagesError::InvalidData)
        }
    }
}

#[derive(Default)]
pub struct Color {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}

impl Color {
    fn get_size_in_bytes(&self) -> usize {
        16
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<Color, AppMessagesError> {
        let red = reader.read_f32()?;
        let green = reader.read_f32()?;
        let blue = reader.read_f32()?;
        let alpha = reader.read_f32()?;
        Ok(Color {red, green, blue, alpha})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>) {
        writer.extend(self.red.to_le_bytes());
        writer.extend(self.green.to_le_bytes());
        writer.extend(self.blue.to_le_bytes());
        writer.extend(self.alpha.to_le_bytes());
    }
}

#[derive(Default)]
pub struct Spectrum {
    pub default_color: Color,
    pub colors: Vec<Color>,
}

impl Spectrum {
    fn get_size_in_bytes(&self) -> usize {
        let mut size: usize = 0;
        size += self.colors.len() * 16;
        size += 18;
        size
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<Spectrum, AppMessagesError> {
        let default_color = Color::from_bytes(reader)?;
        let colors_len = reader.read_u16()?;
        let mut colors: Vec<Color> = Vec::new();
        for _ in 0..colors_len {
            let _el = Color::from_bytes(reader)?;
            colors.push(_el);
        }
        Ok(Spectrum {default_color, colors})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>) {
        self.default_color.write_bytes(writer);
        writer.extend((self.colors.len() as u16).to_le_bytes());
        for _el in &self.colors {
            _el.write_bytes(writer);
        }
    }
}

#[derive(Default)]
pub struct Vector3Message {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl MessageCodec for Vector3Message {
    fn get_message_type(&self) -> MessageType {
        MessageType::Vector3Message
    }

    fn get_size_in_bytes(&self) -> usize {
        12
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<Vector3Message, AppMessagesError> {
        let x = reader.read_f32()?;
        let y = reader.read_f32()?;
        let z = reader.read_f32()?;
        Ok(Vector3Message {x, y, z})
    }

    fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(1_u8);
        }
        writer.extend(self.x.to_le_bytes());
        writer.extend(self.y.to_le_bytes());
        writer.extend(self.z.to_le_bytes());
    }
}

#[derive(Default)]
pub struct NewCharacterMessage {
    pub id: u64,
    pub character_name: String,
    pub job: CharacterClass,
    pub strength: u16,
    pub intelligence: u16,
    pub dexterity: u16,
    pub wisdom: u16,
    pub gold_in_wallet: u32,
    pub nicknames: Vec<String>,
}

impl MessageCodec for NewCharacterMessage {
    fn get_message_type(&self) -> MessageType {
        MessageType::NewCharacterMessage
    }

    fn get_size_in_bytes(&self) -> usize {
        let mut size: usize = 0;
        size += self.character_name.len();
        for s in &self.nicknames {
            size += 1 + s.len();
        }
        size += 24;
        size
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<NewCharacterMessage, AppMessagesError> {
        let id = reader.read_u64()?;
        let character_name = reader.read_string()?;
        let job = reader.read_u8()?;
        let job = CharacterClass::try_from(job)?;
        let strength = reader.read_u16()?;
        let intelligence = reader.read_u16()?;
        let dexterity = reader.read_u16()?;
        let wisdom = reader.read_u16()?;
        let gold_in_wallet = reader.read_u32()?;
        let nicknames_len = reader.read_u16()?;
        let mut nicknames: Vec<String> = Vec::new();
        for _ in 0..nicknames_len {
            let _el = reader.read_string()?;
            nicknames.push(_el);
        }
        Ok(NewCharacterMessage {id, character_name, job, strength, intelligence, dexterity, wisdom, gold_in_wallet, nicknames})
    }

    fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(2_u8);
        }
        writer.extend(self.id.to_le_bytes());
        writer.extend((self.character_name.len() as u8).to_le_bytes());
        writer.extend(self.character_name.as_bytes());
        writer.push(self.job as u8);
        writer.extend(self.strength.to_le_bytes());
        writer.extend(self.intelligence.to_le_bytes());
        writer.extend(self.dexterity.to_le_bytes());
        writer.extend(self.wisdom.to_le_bytes());
        writer.extend(self.gold_in_wallet.to_le_bytes());
        writer.extend((self.nicknames.len() as u16).to_le_bytes());
        for _el in &self.nicknames {
            writer.extend((_el.len() as u8).to_le_bytes());
            writer.extend(_el.as_bytes());
        }
    }
}

#[derive(Default)]
pub struct CharacterJoinedTeam {
    pub character_id: u64,
    pub team_name: String,
    pub team_colors: Vec<Color>,
    pub role: TeamRole,
}

impl MessageCodec for CharacterJoinedTeam {
    fn get_message_type(&self) -> MessageType {
        MessageType::CharacterJoinedTeam
    }

    fn get_size_in_bytes(&self) -> usize {
        let mut size: usize = 0;
        size += self.team_name.len();
        size += self.team_colors.len() * 16;
        size += 13;
        size
    }

    fn from_bytes(reader: &mut BufferReader) -> Result<CharacterJoinedTeam, AppMessagesError> {
        let character_id = reader.read_u64()?;
        let team_name = reader.read_string()?;
        let team_colors_len = reader.read_u16()?;
        let mut team_colors: Vec<Color> = Vec::new();
        for _ in 0..team_colors_len {
            let _el = Color::from_bytes(reader)?;
            team_colors.push(_el);
        }
        let role = reader.read_i16()?;
        let role = TeamRole::try_from(role)?;
        Ok(CharacterJoinedTeam {character_id, team_name, team_colors, role})
    }

    fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(3_u8);
        }
        writer.extend(self.character_id.to_le_bytes());
        writer.extend((self.team_name.len() as u8).to_le_bytes());
        writer.extend(self.team_name.as_bytes());
        writer.extend((self.team_colors.len() as u16).to_le_bytes());
        for _el in &self.team_colors {
            _el.write_bytes(writer);
        }
        writer.extend((self.role as i16).to_le_bytes());
    }
}
