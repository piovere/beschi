// This file was automatically generated by Beschi v0.2.0
// <https://github.com/sjml/beschi>
// Do not edit directly.


const _textDec = new TextDecoder('utf-8');
const _textEnc = new TextEncoder();

export class DataAccess {
    data: DataView;
    currentOffset: number;

    constructor(buffer: ArrayBuffer|DataView) {
        this.currentOffset = 0;
        if (buffer instanceof ArrayBuffer) {
            this.data = new DataView(buffer);
        }
        else {
            this.data = buffer;
        }
    }

    isFinished(): boolean {
        return this.currentOffset >= this.data.byteLength;
    }

    getByte(): number {
        const ret = this.data.getUint8(this.currentOffset);
        this.currentOffset += 1;
        return ret;
    }

    getBool(): boolean {
        return this.getByte() > 0;
    }

    getInt16(): number {
        const ret = this.data.getInt16(this.currentOffset, true);
        this.currentOffset += 2;
        return ret;
    }

    getUint16(): number {
        const ret = this.data.getUint16(this.currentOffset, true);
        this.currentOffset += 2;
        return ret;
    }

    getInt32(): number {
        const ret = this.data.getInt32(this.currentOffset, true);
        this.currentOffset += 4;
        return ret;
    }

    getUint32(): number {
        const ret = this.data.getUint32(this.currentOffset, true);
        this.currentOffset += 4;
        return ret;
    }

    getInt64(): bigint {
        const ret = this.data.getBigInt64(this.currentOffset, true);
        this.currentOffset += 8;
        return ret;
    }

    getUint64(): bigint {
        const ret = this.data.getBigUint64(this.currentOffset, true);
        this.currentOffset += 8;
        return ret;
    }

    getFloat32(): number {
        const ret = this.data.getFloat32(this.currentOffset, true);
        this.currentOffset += 4;
        return Math.fround(ret);
    }

    getFloat64(): number {
        const ret = this.data.getFloat64(this.currentOffset, true);
        this.currentOffset += 8;
        return ret;
    }

    getString(): string {
        const len = this.getByte();
        const strBuffer = new Uint8Array(this.data.buffer, this.currentOffset, len);
        this.currentOffset += len;
        return _textDec.decode(strBuffer);
    }


    setByte(val: number) {
        this.data.setUint8(this.currentOffset, val);
        this.currentOffset += 1;
    }

    setBool(val: boolean) {
        this.setByte(val ? 1 : 0);
    }

    setInt16(val: number) {
        this.data.setInt16(this.currentOffset, val, true);
        this.currentOffset += 2;
    }

    setUint16(val: number) {
        this.data.setUint16(this.currentOffset, val, true);
        this.currentOffset += 2;
    }

    setInt32(val: number) {
        this.data.setInt32(this.currentOffset, val, true);
        this.currentOffset += 4;
    }

    setUint32(val: number) {
        this.data.setUint32(this.currentOffset, val, true);
        this.currentOffset += 4;
    }

    setInt64(val: bigint) {
        this.data.setBigInt64(this.currentOffset, val, true);
        this.currentOffset += 8;
    }

    setUint64(val: bigint) {
        this.data.setBigUint64(this.currentOffset, val, true);
        this.currentOffset += 8;
    }

    setFloat32(val: number) {
        this.data.setFloat32(this.currentOffset, val, true);
        this.currentOffset += 4;
    }

    setFloat64(val: number) {
        this.data.setFloat64(this.currentOffset, val, true);
        this.currentOffset += 8;
    }

    setString(val: string) {
        const strBuffer = _textEnc.encode(val);
        this.setByte(strBuffer.byteLength);
        const arr = new Uint8Array(this.data.buffer);
        arr.set(strBuffer, this.currentOffset);
        this.currentOffset += strBuffer.byteLength;
    }
}

export abstract class Message {
    abstract getMessageType(): MessageType;
    abstract writeBytes(dv: DataView, tag: boolean): void;
    abstract getSizeInBytes(): number;

    static fromBytes(data: DataView|DataAccess|ArrayBuffer): Message | null {
        throw new Error("Cannot read abstract Message from bytes.");
    };
}

export enum MessageType {
  Vector3MessageType = 1,
  NewCharacterMessageType = 2,
  CharacterJoinedTeamType = 3,
}

export function ProcessRawBytes(data: DataView|DataAccess): Message[] {
  let da: DataAccess;
  if (data instanceof DataView) {
    da = new DataAccess(data);
  }
  else {
    da = data;
  }
  const msgList: Message[] = [];
  while (!da.isFinished()) {
    const msgType: number = da.getByte();
    switch (msgType) {
      case 0:
        return msgList;
      case MessageType.Vector3MessageType:
        msgList.push(Vector3Message.fromBytes(da));
        break;
      case MessageType.NewCharacterMessageType:
        msgList.push(NewCharacterMessage.fromBytes(da));
        break;
      case MessageType.CharacterJoinedTeamType:
        msgList.push(CharacterJoinedTeam.fromBytes(da));
        break;
      default:
        throw new Error(`Unknown message type: ${msgType}`);
    }
  }
  return msgList;
}

export enum CharacterClass {
  Fighter = 0,
  Wizard = 1,
  Rogue = 2,
  Cleric = 3,
}

export enum TeamRole {
  Minion = 256,
  Ally = 512,
  Leader = 1024,
  Traitor = -1,
}

export class Color {
  red: number = 0;
  green: number = 0;
  blue: number = 0;
  alpha: number = 0;

  static fromBytes(da: DataAccess): Color {
    const nColor = new Color();
    nColor.red = da.getFloat32();
    nColor.green = da.getFloat32();
    nColor.blue = da.getFloat32();
    nColor.alpha = da.getFloat32();
    return nColor;
  }

  writeBytes(da: DataAccess) {
    da.setFloat32(this.red);
    da.setFloat32(this.green);
    da.setFloat32(this.blue);
    da.setFloat32(this.alpha);
  }

}

export class Spectrum {
  defaultColor: Color = new Color();
  colors: Color[] = [];

  static fromBytes(da: DataAccess): Spectrum {
    const nSpectrum = new Spectrum();
    nSpectrum.defaultColor = Color.fromBytes(da);
    const colors_Length = da.getUint16();
    nSpectrum.colors = Array<Color>(colors_Length);
    for (let i2 = 0; i2 < colors_Length; i2++) {
      nSpectrum.colors[i2] = Color.fromBytes(da);
    }
    return nSpectrum;
  }

  writeBytes(da: DataAccess) {
    this.defaultColor.writeBytes(da);
    da.setUint16(this.colors.length);
    for (let i = 0; i < this.colors.length; i++) {
      let el = this.colors[i];
      el.writeBytes(da);
    }
  }

}

export class Vector3Message extends Message {
  x: number = 0;
  y: number = 0;
  z: number = 0;

  getMessageType() : MessageType { return MessageType.Vector3MessageType; }

  getSizeInBytes(): number {
    return 12;
  }

  static fromBytes(data: DataView|DataAccess|ArrayBuffer): Vector3Message {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else if (data instanceof ArrayBuffer) {
      da = new DataAccess(new DataView(data));
    }
    else {
      da = data;
    }
    try {
      const nVector3Message = new Vector3Message();
      nVector3Message.x = da.getFloat32();
      nVector3Message.y = da.getFloat32();
      nVector3Message.z = da.getFloat32();
      return nVector3Message;
    }
    catch (err) {
      let errMsg = "[Unknown error]";
      if (err instanceof Error) {
        errMsg = `${err.name} -- ${err.message}`;
      }
      throw new Error(`Could not read Vector3Message from offset ${da.currentOffset} (${errMsg})`);
    }
  }

  writeBytes(data: DataView|DataAccess, tag: boolean): void {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else {
      da = data;
    }
    if (tag) {
      da.setByte(MessageType.Vector3MessageType);
    }
    da.setFloat32(this.x);
    da.setFloat32(this.y);
    da.setFloat32(this.z);
  }

}

export class NewCharacterMessage extends Message {
  id: bigint = 0n;
  characterName: string = "";
  job: CharacterClass = CharacterClass.Fighter;
  strength: number = 0;
  intelligence: number = 0;
  dexterity: number = 0;
  wisdom: number = 0;
  goldInWallet: number = 0;
  nicknames: string[] = [];

  getMessageType() : MessageType { return MessageType.NewCharacterMessageType; }

  getSizeInBytes(): number {
    let size: number = 0;
    size += _textEnc.encode(this.characterName).byteLength;
    for (let nicknames_i=0; nicknames_i < this.nicknames.length; nicknames_i++) {
      size += 1 + _textEnc.encode(this.nicknames[nicknames_i]).byteLength;
    }
    size += 24;
    return size;
  }

  static fromBytes(data: DataView|DataAccess|ArrayBuffer): NewCharacterMessage {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else if (data instanceof ArrayBuffer) {
      da = new DataAccess(new DataView(data));
    }
    else {
      da = data;
    }
    try {
      const nNewCharacterMessage = new NewCharacterMessage();
      nNewCharacterMessage.id = da.getUint64();
      nNewCharacterMessage.characterName = da.getString();
      const _job = da.getByte();
      if (CharacterClass[_job] === undefined) {
        throw new Error(`Enum (${_job}) out of range for CharacterClass`);
      }
      nNewCharacterMessage.job = _job;
      nNewCharacterMessage.strength = da.getUint16();
      nNewCharacterMessage.intelligence = da.getUint16();
      nNewCharacterMessage.dexterity = da.getUint16();
      nNewCharacterMessage.wisdom = da.getUint16();
      nNewCharacterMessage.goldInWallet = da.getUint32();
      const nicknames_Length = da.getUint16();
      nNewCharacterMessage.nicknames = Array<string>(nicknames_Length);
      for (let i3 = 0; i3 < nicknames_Length; i3++) {
        nNewCharacterMessage.nicknames[i3] = da.getString();
      }
      return nNewCharacterMessage;
    }
    catch (err) {
      let errMsg = "[Unknown error]";
      if (err instanceof Error) {
        errMsg = `${err.name} -- ${err.message}`;
      }
      throw new Error(`Could not read NewCharacterMessage from offset ${da.currentOffset} (${errMsg})`);
    }
  }

  writeBytes(data: DataView|DataAccess, tag: boolean): void {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else {
      da = data;
    }
    if (tag) {
      da.setByte(MessageType.NewCharacterMessageType);
    }
    da.setUint64(this.id);
    da.setString(this.characterName);
    da.setByte(this.job);
    da.setUint16(this.strength);
    da.setUint16(this.intelligence);
    da.setUint16(this.dexterity);
    da.setUint16(this.wisdom);
    da.setUint32(this.goldInWallet);
    da.setUint16(this.nicknames.length);
    for (let i = 0; i < this.nicknames.length; i++) {
      let el = this.nicknames[i];
      da.setString(el);
    }
  }

}

export class CharacterJoinedTeam extends Message {
  characterID: bigint = 0n;
  teamName: string = "";
  teamColors: Color[] = [];
  role: TeamRole = TeamRole.Minion;

  getMessageType() : MessageType { return MessageType.CharacterJoinedTeamType; }

  getSizeInBytes(): number {
    let size: number = 0;
    size += _textEnc.encode(this.teamName).byteLength;
    size += this.teamColors.length * 16;
    size += 13;
    return size;
  }

  static fromBytes(data: DataView|DataAccess|ArrayBuffer): CharacterJoinedTeam {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else if (data instanceof ArrayBuffer) {
      da = new DataAccess(new DataView(data));
    }
    else {
      da = data;
    }
    try {
      const nCharacterJoinedTeam = new CharacterJoinedTeam();
      nCharacterJoinedTeam.characterID = da.getUint64();
      nCharacterJoinedTeam.teamName = da.getString();
      const teamColors_Length = da.getUint16();
      nCharacterJoinedTeam.teamColors = Array<Color>(teamColors_Length);
      for (let i3 = 0; i3 < teamColors_Length; i3++) {
        nCharacterJoinedTeam.teamColors[i3] = Color.fromBytes(da);
      }
      const _role = da.getInt16();
      if (TeamRole[_role] === undefined) {
        throw new Error(`Enum (${_role}) out of range for TeamRole`);
      }
      nCharacterJoinedTeam.role = _role;
      return nCharacterJoinedTeam;
    }
    catch (err) {
      let errMsg = "[Unknown error]";
      if (err instanceof Error) {
        errMsg = `${err.name} -- ${err.message}`;
      }
      throw new Error(`Could not read CharacterJoinedTeam from offset ${da.currentOffset} (${errMsg})`);
    }
  }

  writeBytes(data: DataView|DataAccess, tag: boolean): void {
    let da: DataAccess;
    if (data instanceof DataView) {
      da = new DataAccess(data);
    }
    else {
      da = data;
    }
    if (tag) {
      da.setByte(MessageType.CharacterJoinedTeamType);
    }
    da.setUint64(this.characterID);
    da.setString(this.teamName);
    da.setUint16(this.teamColors.length);
    for (let i = 0; i < this.teamColors.length; i++) {
      let el = this.teamColors[i];
      el.writeBytes(da);
    }
    da.setInt16(this.role);
  }

}

export const MessageTypeMap = new Map<MessageType, { new(): Message }>([
  [MessageType.Vector3MessageType, Vector3Message],
  [MessageType.NewCharacterMessageType, NewCharacterMessage],
  [MessageType.CharacterJoinedTeamType, CharacterJoinedTeam],
]);

